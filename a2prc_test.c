#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>

#define MAX_PIDS 100 // Maximum number of PIDs to store
#define BUFFER_SIZE 1024

int branch_processes[MAX_PIDS]; // Global array to store found PIDs
int numFound = 0;        // Number of PIDs found

// Checking if a process was created by the logged-in user or not
// returns true/false
bool isProcessCreatedByMe(pid_t provided_UID) {
    // Retrieving the UID of the running process
    uid_t running_process_uid = getuid();

    // For storing the UID of the provided process
    uid_t provided_process_uid = 0;
    FILE *proc_file;
    char proc_file_name[100];
    char proc_file_line[100];
    // Storing the proc string in proc_file_name
    sprintf(proc_file_name, "/proc/%d/status", provided_UID);
    // Reading the proc file
    proc_file = fopen(proc_file_name, "r");
    if (proc_file == NULL) {
        perror("Failed opening proc file for provided process.");
        return false;
    }
    // Reading all the line until it finds the UID field
    while (fgets(proc_file_line, 100, proc_file) != NULL) {
        // Comparing first 4 character to confirm UID field
        if (strncmp(proc_file_line, "Uid:", 4) == 0) {
            // Reading the UID from the line and storing it to provided_process_uid
            sscanf(proc_file_line, "Uid: %d", &provided_process_uid);
            break;
        }
    }
    fclose(proc_file);

    // Returning true or false based on whether the UID of
    // provided_process_uid matches running_process_uid or not
    return (provided_process_uid == running_process_uid);
}


// Function to recursively search for the parent of the child process
// until the root_process is found. The whole branch from root_process to
// process_id is then stored in an array
// returns true/false
bool searchChildProcess(int process_id, int root_process) {
    // Reading the command to get all the processes
    FILE *ps_cmd_output = popen("ps -o pid,ppid -ax", "r");
    if (!ps_cmd_output) {
        perror("popen");
        exit(EXIT_FAILURE);
    }

    char ps_cmd_line[BUFFER_SIZE];
    // Reading the first line which contains the header
    // Ultimately skipping it
    fgets(ps_cmd_line, BUFFER_SIZE, ps_cmd_output);
    // Finally reading all the lines generated by ps command
    while (fgets(ps_cmd_line, BUFFER_SIZE, ps_cmd_output)) {
        // For holding the PID and PPID from the ps_cmd_line
        int pid, ppid;
        // Fetching pid and ppid to store them
        sscanf(ps_cmd_line, "%d %d", &pid, &ppid);
        // Check if the current process is the child process passed as a parameter
        if (pid == process_id) {
            // Check if the root_process provided as a param is the parent
            // of the current process_id
            if (ppid == root_process) {
                // If the root_process matches the ppid then this is indeed the parent
                // of the provided process_id. So, it will be now stored in the array
                branch_processes[numFound++] = pid;
                pclose(ps_cmd_output);
                return true;
            }
            // If the root_process is not the parent of the provided process_id,
            // we will recursively keep searching
            // for the ppid of the parent process of the child process
            else {
                // Recursive parent search call
                bool found = searchChildProcess(ppid, root_process);
                // Finally if the parent of any process is same as the root_process
                // then it means the initial process_id is actually a member of the root_process
                if (found) {
                    // Store the child PID in the global array
                    branch_processes[numFound++] = pid;
                    pclose(ps_cmd_output);
                    return true;
                }
            }
        }
    }
    // Close the ps_cmd_output
    pclose(ps_cmd_output);
    return false;
}

// Function to recursively search for non-direct descendants of a process
void searchNonDirectDescendants(int parentPID)
{
    numFound = 0;
    // Open the pipe to read the output of the ps command
    FILE *pipe = popen("ps -o pid,ppid -ax", "r");
    if (!pipe)
    {
        perror("popen");
        exit(EXIT_FAILURE);
    }

    // Read the output of the ps command line by line
    char line[BUFFER_SIZE];
    fgets(line, BUFFER_SIZE, pipe); // Read and discard the header line
    while (fgets(line, BUFFER_SIZE, pipe))
    {
        // Extract the PID and PPID from the line
        int pid, ppid;
        sscanf(line, "%d %d", &pid, &ppid);
        // Check if the current process is a non-direct descendant of the specified parent process
        if (ppid != parentPID && searchChildProcess(ppid, parentPID))
        {
            // Store the PID of the non-direct descendant
            branch_processes[numFound++] = pid;
        }
    }
    // Close the pipe
    pclose(pipe);
}

void searchDirectDescendants(int parentPID) {
    // Clear the branch_processes array before populating it with new direct descendants
    numFound = 0;

    // Open the pipe to read the output of the ps command
    FILE *pipe = popen("ps -o pid,ppid -ax", "r");
    if (!pipe) {
        perror("popen");
        exit(EXIT_FAILURE);
    }

    // Read the output of the ps command line by line
    char line[BUFFER_SIZE];
    fgets(line, BUFFER_SIZE, pipe); // Read and discard the header line
    while (fgets(line, BUFFER_SIZE, pipe)) {
        // Extract the PID and PPID from the line
        int pid, ppid;
        sscanf(line, "%d %d", &pid, &ppid);

        // Check if the current process is a direct descendant of the specified parent process
        if (ppid == parentPID) {
            // Store the PID of the direct descendant at the end of the branch_processes array
            branch_processes[numFound++] = pid;
        }
    }
    // Close the pipe
    pclose(pipe);
}


// Function to get the parent process ID (ppid) of a given process ID (pid)
int getParentPID(int processID) {
    FILE *pipe = popen("ps -o pid,ppid -ax", "r");
    if (!pipe) {
        perror("popen");
        exit(EXIT_FAILURE);
    }

    char line[BUFFER_SIZE];
    fgets(line, BUFFER_SIZE, pipe); // Read and discard the header line
    while (fgets(line, BUFFER_SIZE, pipe)) {
        int pid, ppid;
        sscanf(line, "%d %d", &pid, &ppid);

        if (pid == processID) {
            pclose(pipe);
            return ppid; // Return the parent process ID
        }
    }
    pclose(pipe);
    return -1; // If the process ID is not found, return -1
}

void searchSiblingProcesses(int processID) {
    // Get the parent process ID (ppid) of the specified processID
    int parentPID = getParentPID(processID);

    // If getParentPID returns -1, it means the specified processID doesn't exist
    if (parentPID == -1) {
        printf("Process with PID %d does not exist.\n", processID);
        return;
    }

    // Use searchDirectDescendants to find all direct descendants of the parent process
    searchDirectDescendants(parentPID);
}

// Function to write the process ID to a file when paused
void writePausedProcessToFile(pid_t pid) {
    // Open the file in append mode
    FILE *file = fopen("paused_processes.txt", "a");
    if (!file) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    // Write the process ID to the file
    fprintf(file, "%d\n", pid);

    // Close the file
    fclose(file);
}

// Function to read the process IDs from the file and continue them
void continuePausedProcesses() {
    // Open the file for reading
    FILE *file = fopen("paused_processes.txt", "r");
    if (!file) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    // Read process IDs from the file and continue them
    char line[256];
    while (fgets(line, sizeof(line), file)) {
        pid_t pid = atoi(line);

        // Send SIGCONT signal to the process
        if (kill(pid, SIGCONT) == 0) {
            printf("Continued process %d\n", pid);
        } else {
            perror("Failed to continue process");
        }
    }

    // Close the file
    fclose(file);

    // Clear the file content
    file = fopen("paused_processes.txt", "w");
    if (!file) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }
    fclose(file);
}

void pauseProcess(int processID) {
    // Send the SIGSTOP signal to pause the process
    if (kill(processID, SIGSTOP) == 0) {
        printf("Process %d paused\n", processID);
        writePausedProcessToFile(processID);
    } else {
        perror("Failed to pause process");
    }
}

// Function to recursively search for defunct processes among the descendants of a process
void searchDefunctProcesses(int parentPID) {
//    numFound = 0;

    // Open the pipe to read the output of the ps command
    FILE *pipe = popen("ps -o pid,state,ppid -ax", "r");
    if (!pipe) {
        perror("popen");
        exit(EXIT_FAILURE);
    }

    // Read the output of the ps command line by line
    char line[BUFFER_SIZE];
    fgets(line, BUFFER_SIZE, pipe); // Read and discard the header line
    while (fgets(line, BUFFER_SIZE, pipe)) {
        // Extract the PID, state, and PPID from the line
        int pid, ppid;
        char state;
        sscanf(line, "%d %c %d", &pid, &state, &ppid);

        // Check if the current process is a descendant of the specified parent process
        if (searchChildProcess(pid, parentPID)) {
            // Check if the process is in a defunct (zombie) state

            if (state == 'Z') {
                printf("here");
                // Store the PID of the defunct process in the global array
                branch_processes[numFound++] = pid;
            }
        }
    }
    // Close the pipe
    pclose(pipe);
}

void searchGrandchildProcesses(int parentPID) {
    // Clear the branch_processes array before populating it with new grandchild processes
    numFound = 0;

    // Open the pipe to read the output of the ps command
    FILE *pipe = popen("ps -o pid,ppid -ax", "r");
    if (!pipe) {
        perror("popen");
        exit(EXIT_FAILURE);
    }

    // Read the output of the ps command line by line
    char line[BUFFER_SIZE];
    fgets(line, BUFFER_SIZE, pipe); // Read and discard the header line
    while (fgets(line, BUFFER_SIZE, pipe)) {
        // Extract the PID and PPID from the line
        int pid, ppid;
        sscanf(line, "%d %d", &pid, &ppid);

        // Get the parent's parent PID (grandparent)
        int grandparentPID = getParentPID(getParentPID(pid));

        // Check if the grandparent PID matches the specified parent process ID
        if (grandparentPID == parentPID) {
            // Store the PID of the grandchild process at the end of the branch_processes array
            branch_processes[numFound++] = pid;
        }
    }
    // Close the pipe
    pclose(pipe);
}

void printProcessStatus(int processID) {
    // Construct the path to the process status file
    char filename[100];
    sprintf(filename, "/proc/%d/status", processID);

    // Open the file for reading
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    // Read the file line by line
    char line[256];
    bool found = false;
    while (fgets(line, sizeof(line), file)) {
        // Check if the line contains the process state
        if (strstr(line, "State:") != NULL) {
            // Extract the process state from the line
            char state;
            sscanf(line, "State: %c", &state);

            // Check if the process is defunct (zombie)
            if (state == 'Z') {
                printf("Process %d is defunct (Zombie)\n", processID);
            } else {
                printf("Process %d is not defunct\n", processID);
            }
            found = true;
            break;
        }
    }

    // Close the file
    fclose(file);

    // If the process ID was not found in /proc, print an error message
    if (!found) {
        printf("Process with PID %d does not exist.\n", processID);
    }
}


int main(int argc, char *argv[]) {
    argc = 4;
    argv[0] = "./a2prc";
    argv[1] = "995534";
    argv[2] = "995529";

    // checking for minimum argument number
    if (argc < 3)
    {
        printf("Please follow the provided format: %s <process_id> <root_process> <command>(optional)\n", argv[0]);
        return 0;
    }

    // Preparing process_id & root_process
    int process_id = atoi(argv[1]);
    int root_process = atoi(argv[2]);

    // Checks if the root_process is created by the logged-in user or not
    if (!isProcessCreatedByMe(root_process)){
        printf("Can not perform task on %d as it was not created by logged-in user.\n", root_process);
        exit(0);
    }
    // Checking whether process_id is under root_process or not
    if (!searchChildProcess(process_id, root_process)) {
        printf("Child process %d not found under parent process %d\n", process_id, root_process);
        exit(0);
    }

    // For the default command
    if (argc == 3) {
        // As branch_processes already contains all the branch members from provided
        // root_process to process_id, printing the last two pid will be enough
        for (int i = numFound - 1; i >= numFound - 2 && i >= 0; --i) {
            printf("%d ", branch_processes[i]);
        }
        printf("\n");
        return 0;
    }
    if (argc == 4) {
        if (strcmp(argv[3], "-rp") == 0){
            // Kill the processes found in the branch_processes array
            for (int i = 0; i < numFound; ++i) {
                if (branch_processes[i] == process_id)
                {
                    if (kill(branch_processes[i], SIGKILL) == 0) {
                        printf("Process %d killed\n", branch_processes[i]);
                    } else {
                        printf("Failed to kill process %d\n", branch_processes[i]);
                    }
                }
            }
            return 0;
        }
        else if (strcmp(argv[3], "-pr") == 0){
            // Check if the parent process was created by the current user
            if (isProcessCreatedByMe(root_process)){
                // Kill the parent process
                if (kill(root_process, SIGKILL) == 0){
                    printf("Parent process %d killed\n", root_process);
                }
                else{
                    printf("Failed to kill parent process %d\n", root_process);
                }
            }
            else{
                printf("The parent process with PID %d was not created by you.\n", root_process);
            }
            return 0;
        }
        else if (strcmp(argv[3], "-xn") == 0){
            // Search for non-direct descendants and print their PIDs
            searchNonDirectDescendants(process_id);
            printf("Non-direct descendants of process %d:\n", process_id);
            for (int i = 0; i < numFound; ++i)
            {
                printf("%d\n", branch_processes[i]);
            }
            return 0;
        }
        else if (strcmp(argv[3], "-xd") == 0){
            // Search for non-direct descendants and print their PIDs
            searchDirectDescendants(process_id);
            printf("direct descendants of process %d:\n", process_id);
            for (int i = 0; i < numFound; ++i)
            {
                printf("%d\n", branch_processes[i]);
            }
            return 0;
        }
        else if (strcmp(argv[3], "-xs") == 0){
            // Search for non-direct descendants and print their PIDs
            searchSiblingProcesses(process_id);
            printf("siblings of process %d:\n", process_id);
            for (int i = 1; i < numFound; ++i)
            {
                printf("%d\n", branch_processes[i]);
            }
            return 0;
        }
        else if (strcmp(argv[3], "-xt") == 0){
            pauseProcess(process_id);
            return 0;
        }
        else if (strcmp(argv[3], "-xc") == 0){
            continuePausedProcesses();
            return 0;
        }
        else if (strcmp(argv[3], "-xz") == 0){
            searchDefunctProcesses(process_id);
            // Print the PIDs of defunct processes
            printf("Defunct processes among the descendants of process %d:\n", process_id);
            for (int i = 0; i < numFound; ++i) {
                printf("%d\n", branch_processes[i]);
            }
            return 0;
        }
        else if (strcmp(argv[3], "-xg") == 0){
            searchGrandchildProcesses(process_id);
            // Print the PIDs of defunct processes
            printf("Grandchild of process %d:\n", process_id);
            for (int i = 0; i < numFound; i++) {
                printf("%d\n", branch_processes[i]);
            }
            return 0;
        }
        else if (strcmp(argv[3], "-zs") == 0){
            printProcessStatus(process_id);
            return 0;
        }
    }
    printf("Please follow the provided format: %s <process_id> <root_process> <command>(optional)\n", argv[0]);
    return 0;
}
